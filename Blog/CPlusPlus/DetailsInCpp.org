# -*- mode: org -*-
# Last modified: <2012-02-20 10:23:38 Monday by richard>
#+STARTUP: showall
#+TITLE:   C++ Details

* Tips
  1. Direct assigment syntax is more flexible and can be slightly more
     efficient.
     #+begin_src c++ :tangle yes
int ival = 2048; //copy-initialization
int ival(2048);  //direct-initialization
     #+end_src
  2. Every object of built-in type should be initialized.
  3. Use const_cast almost always indicates a design flaw.
  4. When not certain which container the application should use, try
     to write your code so that it uses only operations common to both
     bevctors and lists.

* Good habits
  1. Define an object near the point at which the object is first
     used, and then initialize it.
  2. Arguments should not need casts when calling oer-loaded
     functions: the need for a cast means that the parameter sets are
     designed poorly.
  3. It is usually a good idea to define array parameters as opinters,
     rather than using the array syntax.
  4. Using != in preference to < as a matter of habit.
  5. in multi-comment style, Begin each line in the comment with
     asterisk, thus indicating that the entire range is part of a
     multi-line comment.
  6. Headers for declarations, not definitions.(will be included
     multiple times)
     But except:
     1. classes;
     2. const objects whose value is known at compile time;
     3. inline functions.
     4. When a const is initialized by a value that is not a constant
        expression, then it shouldn'tbe defined in header file.
  7. We should always use the fully qualified library names: inside
     header files.
  8. Any variable used to store the result from string size operation
     ought to be of type class::size_type, It is particularly
     important not to assign the return from size to an int.
  9. It was almost right to use double.
  10. Programs that use undefined behavior are in error.
      Programs also shouldn't rely on machine-dependent behavior.
  11. Identifiers shouldn't
      - contain two consecutive underscores
      - begin with an underscore followed immediately by an upper-case
        letter.
      - begin with an underscore, when defined outside a function.
      - Using Operator alternative names.(table:)
      | C++ Operator Alternative names       |
      |--------------------------------------|
      | and     bitand  compl  not_eq  or_eq |
      | xor_eq  and_eq  bitor  not     or    |
      | xor                                  |
      |--------------------------------------|
  12. A null statement should be commented, so that anyone reading the
      code can see that the statement was omitted intentionally.
  13. Use EXIT_FAILURE and EXIT_SUCCESS in the cstdlib header to make
      return values machine-independent.
  14. It is usually a bad idea to declare a function locally. Function
      declarations should go in header files.
  15. When dealing with the algorithms, it is best to think of the
      iterators on associative containers as if they were input
      iterators that also support decrement, not as full bidirectional
      iterators.
  16. It's a good idea to write constructor initilizers in the same
      order as the members are declared. Moreover, when possible,
      avoid using members to initilize other members.
  17. If a class contains datamember of built-in or compound type,
      then the class should not rely on the synthesized default
      constructor.
  18. It is almost always right to provide a default constructor if
      other constructors are being defined.
  19. Makeing constructor =explicit= may avoid mistakes, and a user
      can explicitly construct an object when a conversion is useful.
  20. It is a good idea to group friend declarations together either
      at the beginning or end of the class definition.
      
* Details (Something we may overlooked)

** C++ Library

*** Library Overview:
    1. The library is not required to check the value of the index.
    2. Using difference_type to store :iter1 - iter2.
    3. size_t type is defined in the cstddef header.
    4. the IO type can be used in a condition, but the vector and
       string types may not be used as a condition.
    5. Don't cache the iterator from the end.
       #+begin_src c++ :tangle yes
    std::vector<int>::iterator first = vint.begin(),
                                last = vint.end();// cache the end.
       #+end_src
    6. using at(n) method in vector and deque when need check to check
       out-of-range error.

**** pair type
     defined in utility header.
     operations p1 < p2: is 
     #+begin_src c++ :tangle yes
(p1.first < p2.first) || (p1.second < p2.second)
     #+end_src

**** Iterators
    1. Invalidate the iterators' operations.(Be aware!)
       - insert
         (Exception: insert front and back in deque)
       - push_back
       - push_front
       - resize
       - assign
       - erase(but erase will return the iterator after the one
         deleted)
       - etc.
    2. Operation on iterator but not invalidate.
       - Swap(iterators will refer to diff. object)

**** Which container to use.
     1. FIXME:



*** Boost:

*** priority_queue
    A priority_queue requires random access and so can be built on a
    vector or a deque but not on a list.

*** vector: 
    1. It is always to let the vector grow by adding elements to it
       dynamically as the element values are known.
    2. If vector is empty, then the iterator returned from begin does
       not denote any element.

*** map 
    The key type needs to support *only* the < operator. 

*** multimap
    The version of erase that take a key removes all elements with
    that key.

*** Arrays:
    1. The right type to use for the index is size_t.

*** bitset:
    1. The bits are read from the string from right to left.
       - The numbering conventions of strings and bitsets are
         inversely related. 

*** String Library:
    1. Caller is respondible for size of a destination string.
    2. Using strn- series functions.
    3. Different between c_str() and data():
       - Use c_str() if you want a null terminated string.
       - Use data() if you don't need the string to be null
         terminated. It may turn out to perform better than c_str().
         (Especially when deal with arbitrary binary data use string.)

         

    4. function table:
       | <25>                      |           |
       | common functions          | head file |
       |---------------------------+-----------|
       | strlen(s)                 | <cstring> |
       | strcmp(s1, s2)            | $4        |
       | strcat(s1, s2)            | $4        |
       | strcpy(s1, s2)            | $4        |
       | strncat(s1, s2, n)        | $4        |
       | strncpy(s1, s2, n)        | $4        |
       |---------------------------+-----------|

*** IO library
    - Hitting the end-of-file also sets the failbit.
    - If we reuse a file stream to read or write more than one file,
      we must clear the stream before using it to read from another
      file.
    - Mode is an Attribute of FILE, not a stream.
    - File mode combination:
      | combinations | affect                                                             |
      |--------------+--------------------------------------------------------------------|
      | out          | open for output; deletes existing data in the file                 |
      | out app      | open for output; all writes at the end of file                     |
      | out trunc    | same as out                                                        |
      | in           | open for input                                                     |
      | in out       | open for both input and output                                     |
      | in out trunc | open for both input and output, deletes existing data in the file. |
      |--------------+--------------------------------------------------------------------|
    - condition state:
      | Name             | Meaning                                                    |
      |------------------+------------------------------------------------------------|
      | strm::iostate    | Name of machine-dependent integral type                    |
      | strm::badbit     | strm::iostate indicate that a stream is corrupted          |
      | strm::failbit    | strm::iostate indicate that IO operation failed            |
      | strm::odfbit     | strm::iostate indicate the a stream hit end-of-file        |
      | s.eof()          | true if eofbit in the stream s is set                      |
      | s.fail()         | true if failbit                                            |
      | s.bad()          | true if badbit  in the stream s is set                     |
      | s.good()         | true if stream s is in a valid state.                      |
      | s.clear()        | Reset all condition values in the stream s to valid state. |
      | s.clear(flag)    | Set specified condition(flag) state in s to valid.         |
      | s.setstate(flag) | Add specified condition(flag) to s.                        |
      | s.rdstate()      | Returns current condition of s as an strm::iostate value.  |
      |------------------+------------------------------------------------------------|
    - When testing IO you can use:
      #+begin_src c++ :tangle yes
      is.setstate(ifstream::badbit|ifstream::failbit)
      #+end_src

** new and delete
   - delete [] pi;
     If the empty bracket pair is omitted, it is an error, but an
     error that the compiler is unlikey to catch; the program may fail
     at run time.
   - If the new expression cannot acquire the requested memory, it
     throws an exception named bad_alloc.

** Compile details
   - name lookup happens before typechecking.

** Debug details
*** four constants useful in debugging:
    | name     | meaning                     |
    |----------+-----------------------------|
    | __FILE__ | name of the file.           |
    | __LINE__ | current line number.        |
    | __TIME__ | time the file was compiled. |
    | __DATE__ | date the file was compiled. |
    |----------+-----------------------------|
    
*** The assert macro 
    assert macro is defined in the assert header, which we must
    include in any file that uses assert.
    #+begin_src c++ :tangle yes
assert(word.size() > threshold);
    #+end_src

*** NDEBUG
    We can write conditional debugging code using the NDEBUG preprocessor.


** bitwise operators
*** left-shift and right-shift operand.
    - The right-hand operand must not be negative and must be a value
      that is strictly less than the number of bits in the left-hand
      operand. Otherwise, the effect of the operation is undefined.
    - Bit code snippets:
      #+begin_src c++ :tangle yes
    bitv |= 1UL << 27;//set bit 27
    bitv &= ~(1UL << 27); //turn off bit 27;
      #+end_src

** Exception Handling mechanism
*** try
    - Once the catch clause finishes, executoin continues with the
      statement immediately following the last catch clause of the try
      block.
*** throw
    - A throw expression is usually followed by a semicolon, makeing
      it into an expression statement.

*** Standard Exceptions.
    - Defined in 4 headers:
      1. The exception header defines the most general kind of
         exception class named exception.
      2. The stdexcept header defines several general purpose
         exception classes.
         standard exception class in <stdexcept>
         |------------------+--------------------------------------------------------------------------------------|
         | type             | details                                                                              |
         |------------------+--------------------------------------------------------------------------------------|
         | exception        | The most general kind of problem                                                     |
         | runtime_error    | problem only can be detected at runtime                                              |
         | range_error      | outside the range of valuesthat are meaningful                                       |
         | overflow_error   | computation that overflowed                                                          |
         | underflow_error  | computation that underflowed                                                         |
         | logic_error      | problem can be detected before runtime                                               |
         | domain_error     | <logic_error>:argument for which no result exists                                    |
         | invalid_argument | <logic_error>:inappropriate argument                                                 |
         | length_error     | <logic_error>:attempt to create an object larger than the maximum size for that type |
         | out_of_range     | <logic_error>:used a value outside the valid range.                                  |
         |------------------+--------------------------------------------------------------------------------------|
      3. The new header defines the bad_alloc exception type.
      4. The type_info header defines the bad_cast exception type.
    - The exception, bad alloc, and bad_case type define only a
      default constructor.

** Enumerator
   1. An enumerator value need not be unique.
   2. The type to which an enum object enumerator is promoted is
      machine-defined and depends on the value of the largest
      enumerator.(at least to int)

** Reference and Pointers
*** Reference:
    - A non-const reference may be attached only to an object of the
      same type as the reference itself.
    - A const reference may be bound to an object of a different but
      related type or to an rvalue.

*** Pointers:
    - the type void* is a special pointer type that can hold an
      address of any object.
    - Using ptrdiff_t to store the result of two pointers.
      ptrdiff_t type is a machine-specific type and is defined in the
      cstddef header.
    - pointers and typedef:
      #+begin_src c++ :tangle yes
int (*ip)[4]             // style 1

typedef int int_array[4] // style 2
int array *ip;
      #+end_src


** Scope:
*** Statement scope:
    - Variables defined in a condition must be initialized.
*** File scope:
    - Nonconst variables are extern by default. To make a const
      variable accessible to other files, we must explicitly specify
      that it is extern.
    - const variables declared at global scope are local to the file in which the object is defined.
** Lvalue and Rvalue:
   - lvalue may appear as either the left-hand or right-hand side of
     an assignment.(an lvalue yields an object)
   - Rvalue may apear on the right but not left-hand side of an
     assignment.
   - The address-of operator may be applied only to an lvalue.
   - Prefix increment yields an lvalue.
     Postfix increment yields an rvalue.

** A definition is also a declaration.
   If an initializer is present, the declaration is treated as a
   definition even if the declaration is labeled extern.


** switch and case
  1. It can be useful always to define a default label even if there
     is no processing to be done in the default case.
  2. case labels must be constant integral expressions.
     Expression will be determined at compile time.
  3. Variables can be defined following only the last case or default
     label.
     - One smart way to surround this point is using bracket.


** Type and operators
*** sizeof
    - The sizeof operator returns a value of type size_t.
    - sizeof(ia)/sizeof(*ia) returns the number of element in ia.
    - sizeof char or an expression of type char is guaranteed to
      be 1.

*** The integers, int, short, and long, are all signed by default.
    - The char type is respresented using either the signed char or
      unsigned char version.(compiler-dependent)

*** Ellipsis paramter
    - Ellipsis parameters are in C++ in order to compile C programs
      that use varargs.
    - Only simple data types from the C++ program should be passed to
      functions with ellipses parameters.

*** Every literal has an associated type and exists only for the built-in type.
    - There are no literals of type short.
    - By default, floating-point literals are type double.
    - The type of a wide string literal is an array of constant wide
      character. Also terminated by wide null character.
    - The result is undefined when concatenate a string literal and a
      wide string literal.
    #+begin_src c++ :tangle yes
     std::cout << "string here" L"wide string here" << std::endl;
     std::cout << "string here again" << std::endl;
     std::cout << L"wide string here again" << std::endl;
    #+end_src
    - Example table:
    | type                       | Example                 |
    |----------------------------+-------------------------|
    | unsigned                   | 123u                    |
    | unsigned long              | 1024UL, 8LU             |
    | long                       | 1L                      |
    | double                     | 0., 0e0                 |
    | float                      | 3.14F, 3.1415E0f, .001f |
    | bool                       | true, false             |
    | char                       | 'a'                     |
    | char*(String literal)      | "string"                |
    | wchar_t                    | L'a'                    |
    | wchar_t*(w-string literal) | L"wide string"          |

*** Using wide-character literal of type wchar_t by 

*** Escape sequence form:
    - \ooo(three octal digits.)
      - \7 (bell) \12 (newline) \40 (blank)
      - \0 (null) \062 (`2`)    \115 (`M`)
    - \xddd(hexadecimal escape sequence.)

*** return
    - failing to provide a return after a loop that does contain a
      return is particularly insidious because many compilers will not
      detect it. The behavior at run time is undefined.
** An istream becomes invalid when we hit end-of-file or encounter an invalid input.

** Name are resolved where thay appear within the file.

** Buffers:

*** Output buffers are not flushed if the program terminates abnormally.

*** Output buffers usually must be explicitly flushed to force the buffer to be written.

*** cin and cout are binded default;that is cin.tie(&cout)
    reading cin flushes cout; cout is also flushed when the program ends normally.

*** By default, writes to cerr are not buffered and clog are buffered.


* Methods

** The use a class we need to know three things:
   1. What is its name?
   2. Where is it defined?
   3. What operations does it support?


